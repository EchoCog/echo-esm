"""
Probabilistic Logic Networks (PLN) for ESM3 Cognitive Framework

Implements PLN reasoning for protein validation and analysis:
- Multi-factor protein sequence validation
- Structure-function relationship reasoning
- Truth value computation with uncertainty
- Proof generation for protein properties

PLN provides sophisticated probabilistic reasoning over protein knowledge.
"""

from typing import Dict, List, Optional, Tuple, Any
import numpy as np
from dataclasses import dataclass
import math

from .atomspace import AtomHandle, TruthValue, ProteinAtomSpace
from esm.sdk.api import ESMProtein


@dataclass
class PLNProof:
    """Proof generated by PLN reasoning"""
    theorem: str
    premises: List[AtomHandle]
    conclusion: AtomHandle
    confidence: float
    steps: List[str]


class ProteinPLN:
    """
    Probabilistic Logic Networks for protein reasoning
    
    Applies PLN reasoning patterns to:
    - Validate protein sequences and structures
    - Reason about function-structure relationships
    - Generate proofs for protein properties
    - Handle uncertainty in biological data
    """
    
    def __init__(self, atomspace: ProteinAtomSpace):
        self.atomspace = atomspace
        self.validation_rules = {}
        self._initialize_rules()
    
    def _initialize_rules(self):
        """Initialize PLN validation rules"""
        self.validation_rules = {
            'sequence_validity': self._validate_sequence_rule,
            'structure_coherence': self._validate_structure_rule,
            'function_consistency': self._validate_function_rule,
            'amino_acid_relationships': self._validate_aa_relationships_rule
        }
    
    def _validate_sequence_rule(self, protein_atom: AtomHandle) -> TruthValue:
        """Validate protein sequence using PLN reasoning"""
        # Get sequence-related atoms
        sequence_atoms = []
        incoming = self.atomspace.get_incoming_links(protein_atom)
        
        for link in incoming:
            if "sequence" in link.name.lower():
                sequence_atoms.append(link)
        
        if not sequence_atoms:
            return TruthValue(0.5, 0.3)  # Unknown sequence
        
        # Compute validation factors
        length_factor = self._compute_length_factor(protein_atom)
        composition_factor = self._compute_composition_factor(protein_atom)
        complexity_factor = self._compute_complexity_factor(protein_atom)
        
        # PLN truth value revision
        strength = self._combine_strengths([length_factor, composition_factor, complexity_factor])
        confidence = self._combine_confidences([0.8, 0.7, 0.6])
        
        return TruthValue(strength, confidence)
    
    def _validate_structure_rule(self, protein_atom: AtomHandle) -> TruthValue:
        """Validate protein structure coherence"""
        structure_links = [link for link in self.atomspace.get_incoming_links(protein_atom)
                          if "structure" in link.name.lower()]
        
        if not structure_links:
            return TruthValue(0.5, 0.2)  # No structure information
        
        # Structure validation factors
        fold_consistency = 0.8  # Placeholder for folding validation
        contact_validity = 0.9   # Placeholder for contact map validation
        geometric_plausibility = 0.85  # Placeholder for geometric checks
        
        strength = self._combine_strengths([fold_consistency, contact_validity, geometric_plausibility])
        confidence = 0.7
        
        return TruthValue(strength, confidence)
    
    def _validate_function_rule(self, protein_atom: AtomHandle) -> TruthValue:
        """Validate function-structure consistency"""
        function_links = [link for link in self.atomspace.get_incoming_links(protein_atom)
                         if "function" in link.name.lower()]
        
        if not function_links:
            return TruthValue(0.6, 0.4)  # Unknown function
        
        # Function validation based on structural features
        active_site_presence = 0.8
        domain_architecture = 0.9
        evolutionary_conservation = 0.7
        
        strength = self._combine_strengths([active_site_presence, domain_architecture, evolutionary_conservation])
        confidence = 0.6
        
        return TruthValue(strength, confidence)
    
    def _validate_aa_relationships_rule(self, protein_atom: AtomHandle) -> TruthValue:
        """Validate amino acid relationship patterns"""
        aa_atoms = [atom for atom in self.atomspace.get_atoms_by_name_pattern("AminoAcid_")
                   if any(link for link in self.atomspace.get_incoming_links(atom) 
                         if protein_atom in self.atomspace.get_outgoing_atoms(link))]
        
        if len(aa_atoms) < 2:
            return TruthValue(0.5, 0.3)
        
        # Validate amino acid relationships
        hydrophobicity_patterns = self._validate_hydrophobicity_patterns(aa_atoms)
        charge_distribution = self._validate_charge_distribution(aa_atoms)
        secondary_structure_propensity = 0.75  # Placeholder
        
        strength = self._combine_strengths([hydrophobicity_patterns, charge_distribution, secondary_structure_propensity])
        confidence = 0.65
        
        return TruthValue(strength, confidence)
    
    def _compute_length_factor(self, protein_atom: AtomHandle) -> float:
        """Compute length-based validation factor"""
        length_evals = [link for link in self.atomspace.get_incoming_links(protein_atom)
                       if "sequenceLength" in link.name]
        
        if not length_evals:
            return 0.5
        
        # Extract length from evaluation link name
        try:
            length_str = length_evals[0].name.split('=')[1]
            length = float(length_str)
            
            # Validate reasonable protein length (20-5000 amino acids)
            if 20 <= length <= 5000:
                return 0.9
            elif 10 <= length < 20 or 5000 < length <= 10000:
                return 0.7
            else:
                return 0.3
        except:
            return 0.5
    
    def _compute_composition_factor(self, protein_atom: AtomHandle) -> float:
        """Validate amino acid composition"""
        # Get amino acid distribution
        aa_counts = {}
        aa_atoms = [atom for atom in self.atomspace.get_atoms_by_name_pattern("AminoAcid_")]
        
        for aa_atom in aa_atoms:
            if aa_atom.name.startswith("AminoAcid_"):
                aa_type = aa_atom.name.split("_")[1]
                aa_counts[aa_type] = aa_counts.get(aa_type, 0) + 1
        
        if not aa_counts:
            return 0.5
        
        total_aa = sum(aa_counts.values())
        
        # Check for reasonable amino acid distribution
        # Avoid proteins with >50% of any single amino acid
        max_fraction = max(count/total_aa for count in aa_counts.values())
        
        if max_fraction > 0.5:
            return 0.4
        elif max_fraction > 0.3:
            return 0.6
        else:
            return 0.9
    
    def _compute_complexity_factor(self, protein_atom: AtomHandle) -> float:
        """Compute sequence complexity factor"""
        # Placeholder for sequence complexity analysis
        # Could implement entropy-based measures, repeat detection, etc.
        return 0.75
    
    def _validate_hydrophobicity_patterns(self, aa_atoms: List[AtomHandle]) -> float:
        """Validate hydrophobicity distribution patterns"""
        # Simplified hydrophobicity validation
        hydrophobic_aas = {'A', 'V', 'I', 'L', 'M', 'F', 'Y', 'W'}
        hydrophilic_aas = {'R', 'N', 'D', 'C', 'E', 'Q', 'G', 'H', 'K', 'P', 'S', 'T'}
        
        hydrophobic_count = 0
        hydrophilic_count = 0
        
        for aa_atom in aa_atoms:
            if aa_atom.name.startswith("AminoAcid_"):
                aa_type = aa_atom.name.split("_")[1]
                if aa_type in hydrophobic_aas:
                    hydrophobic_count += 1
                elif aa_type in hydrophilic_aas:
                    hydrophilic_count += 1
        
        total = hydrophobic_count + hydrophilic_count
        if total == 0:
            return 0.5
        
        # Good balance of hydrophobic/hydrophilic residues
        hydrophobic_ratio = hydrophobic_count / total
        if 0.3 <= hydrophobic_ratio <= 0.7:
            return 0.9
        elif 0.2 <= hydrophobic_ratio <= 0.8:
            return 0.7
        else:
            return 0.5
    
    def _validate_charge_distribution(self, aa_atoms: List[AtomHandle]) -> float:
        """Validate charge distribution patterns"""
        positive_aas = {'R', 'H', 'K'}
        negative_aas = {'D', 'E'}
        
        positive_count = 0
        negative_count = 0
        
        for aa_atom in aa_atoms:
            if aa_atom.name.startswith("AminoAcid_"):
                aa_type = aa_atom.name.split("_")[1]
                if aa_type in positive_aas:
                    positive_count += 1
                elif aa_type in negative_aas:
                    negative_count += 1
        
        # Reasonable charge balance
        total_charged = positive_count + negative_count
        if total_charged == 0:
            return 0.7  # Neutral is okay
        
        charge_balance = abs(positive_count - negative_count) / total_charged
        if charge_balance <= 0.3:
            return 0.9
        elif charge_balance <= 0.6:
            return 0.7
        else:
            return 0.5
    
    def _combine_strengths(self, strengths: List[float]) -> float:
        """Combine multiple strength values using PLN revision"""
        if not strengths:
            return 0.5
        
        # Use weighted geometric mean for strength combination
        result = 1.0
        for s in strengths:
            result *= s
        
        return result ** (1.0 / len(strengths))
    
    def _combine_confidences(self, confidences: List[float]) -> float:
        """Combine confidence values"""
        if not confidences:
            return 0.5
        
        # Use independence assumption for confidence combination
        combined = 1.0
        for c in confidences:
            combined *= (1.0 - c)
        
        return 1.0 - combined
    
    def validate_protein(self, protein_atom: AtomHandle) -> TruthValue:
        """Complete PLN-based protein validation"""
        validations = []
        
        for rule_name, rule_func in self.validation_rules.items():
            try:
                validation = rule_func(protein_atom)
                validations.append(validation)
            except Exception as e:
                # Handle validation errors gracefully
                validations.append(TruthValue(0.5, 0.2))
        
        if not validations:
            return TruthValue(0.5, 0.3)
        
        # Combine all validation results
        strengths = [v.strength for v in validations]
        confidences = [v.confidence for v in validations]
        
        combined_strength = self._combine_strengths(strengths)
        combined_confidence = self._combine_confidences(confidences)
        
        return TruthValue(combined_strength, combined_confidence)
    
    def generate_protein_proof(self, protein_atom: AtomHandle, theorem: str) -> PLNProof:
        """Generate PLN proof for protein theorem"""
        premises = []
        steps = []
        
        # Collect relevant premises
        incoming = self.atomspace.get_incoming_links(protein_atom)
        for link in incoming:
            if link.truth_value and link.truth_value.confidence > 0.5:
                premises.append(link)
        
        # Generate proof steps
        validation = self.validate_protein(protein_atom)
        
        steps.append(f"1. Protein {protein_atom.name} has sequence validation: {validation.strength:.3f}")
        steps.append(f"2. Evidence confidence: {validation.confidence:.3f}")
        steps.append(f"3. Applied PLN reasoning rules: {list(self.validation_rules.keys())}")
        steps.append(f"4. Combined evidence supports theorem: {theorem}")
        
        # Create conclusion atom
        conclusion = AtomHandle(
            self.atomspace._generate_id(),
            "EvaluationLink", 
            f"Theorem({theorem})",
            validation
        )
        
        return PLNProof(
            theorem=theorem,
            premises=premises,
            conclusion=conclusion,
            confidence=validation.confidence,
            steps=steps
        )
    
    def generate_trial_balance_proof(self, protein_atoms: List[AtomHandle]) -> PLNProof:
        """Generate trial balance proof for protein set"""
        theorem = "TrialBalance: All proteins maintain structural-functional consistency"
        premises = []
        steps = []
        
        total_validation = TruthValue(1.0, 1.0)
        
        for i, protein_atom in enumerate(protein_atoms):
            validation = self.validate_protein(protein_atom)
            premises.extend(self.atomspace.get_incoming_links(protein_atom))
            
            steps.append(f"{i+1}. Protein {protein_atom.name}: validation={validation.strength:.3f}")
            
            # Combine validations
            total_validation = TruthValue(
                total_validation.strength * validation.strength,
                min(total_validation.confidence, validation.confidence)
            )
        
        steps.append(f"Trial Balance Result: strength={total_validation.strength:.3f}, confidence={total_validation.confidence:.3f}")
        
        conclusion = AtomHandle(
            self.atomspace._generate_id(),
            "EvaluationLink",
            "TrialBalanceValid",
            total_validation
        )
        
        return PLNProof(
            theorem=theorem,
            premises=premises,
            conclusion=conclusion,
            confidence=total_validation.confidence,
            steps=steps
        )
    
    def generate_function_structure_proof(self, protein_atom: AtomHandle) -> PLNProof:
        """Generate proof for function-structure relationship"""
        theorem = "Function-Structure Consistency"
        
        structure_validation = self._validate_structure_rule(protein_atom)
        function_validation = self._validate_function_rule(protein_atom)
        
        # Combine structure and function validations
        consistency = TruthValue(
            (structure_validation.strength + function_validation.strength) / 2,
            min(structure_validation.confidence, function_validation.confidence)
        )
        
        premises = self.atomspace.get_incoming_links(protein_atom)
        steps = [
            f"1. Structure validation: {structure_validation.strength:.3f} (conf: {structure_validation.confidence:.3f})",
            f"2. Function validation: {function_validation.strength:.3f} (conf: {function_validation.confidence:.3f})",
            f"3. Combined consistency: {consistency.strength:.3f} (conf: {consistency.confidence:.3f})"
        ]
        
        conclusion = AtomHandle(
            self.atomspace._generate_id(),
            "EvaluationLink",
            "FunctionStructureConsistent",
            consistency
        )
        
        return PLNProof(
            theorem=theorem,
            premises=premises,
            conclusion=conclusion,
            confidence=consistency.confidence,
            steps=steps
        )